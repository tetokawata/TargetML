---
title: "Example"
format: html
execute: 
  warning: false
  message: false
---

# SetUp

```{r SetUp}
set.seed(149)

pacman::p_load(
  tidyverse,
  mlr3verse,
  mlr3pipelines,
  recipes,
  DALEX,
  embed
)


lgr::get_logger("mlr3")$set_threshold("error") # Errorのみを表示
lgr::get_logger("bbotk")$set_threshold("error") # Errorのみを表示
```


# Data

```{r CleanData}
TargetStructure <- c("ＳＲＣ","ＲＣ")

TargetRoom <- c("オープンフロア","スタジオ","メゾネット")

Raw <- arrow::read_parquet("~/Dropbox/DataClean/RetailJPN/AllPrefectture.parquet") |> 
  filter(今後の利用目的 == "住宅") |> 
  filter(用途 == "住宅") |> 
  filter(改装 != "") |> 
  filter(間取り != "") |> 
  filter(都市計画 != "") |> 
  filter(最寄駅.名称 != "") |> 
  filter(都道府県名 == "東京都") |> 
  filter(str_detect(市区町村名, "区")) |> 
  filter(建物の構造 %in% TargetStructure) |> 
  filter(!(間取り %in% TargetRoom)) |> 
  mutate(Quartely = 
           if_else(str_detect(取引時点,"１"),
                   1,
                   0)
         ) |> 
   mutate(Quartely = 
           if_else(str_detect(取引時点,"２"),
                   2,
                   Quartely)
         ) |> 
   mutate(Quartely = 
           if_else(str_detect(取引時点,"３"),
                   3,
                   Quartely)
         ) |> 
   mutate(Quartely = 
           if_else(str_detect(取引時点,"４"),
                   4,
                   Quartely)
         ) |> 
  mutate(TradePeriod = str_sub(取引時点,1,4) |> 
           as.numeric()
         ) |> 
  filter(TradePeriod %in% c(2019,2021)) |> 
  mutate(
    TempBuildYear = 
      str_sub(建築年,3,-2) |> 
      as.numeric(),
    TempGengo = str_sub(建築年,1,2)
    ) |> 
  mutate(
    BuildYear = if_else(
      TempGengo == "令和",
      TempBuildYear + 2018,
      TempBuildYear
      )
  ) |> 
  mutate(
    BuildYear = if_else(
      TempGengo == "平成",
      TempBuildYear + 1988,
      BuildYear
      )
  ) |> 
  mutate(
    BuildYear = if_else(
      TempGengo == "昭和",
      TempBuildYear + 1925,
      BuildYear
      )
  ) |> 
  mutate(
    Price = 取引価格.総額./(10^6),
    Tenure = TradePeriod - BuildYear,
    DistanceStation = 最寄駅.距離.分. |> as.numeric(),
    Size = 面積... |> as.numeric(),
    Youseki = 容積率... |> as.numeric(),
    Kenpei = 建ぺい率... |> as.numeric(),
    RoomNum = if_else(str_detect(間取り,"１"),1,0),
    RoomNum = if_else(str_detect(間取り,"２"),2,RoomNum),
    RoomNum = if_else(str_detect(間取り,"３"),3,RoomNum),
    RoomNum = if_else(str_detect(間取り,"４"),4,RoomNum),
    RoomNum = if_else(str_detect(間取り,"５"),5,RoomNum),
    RoomNum = if_else(str_detect(間取り,"６"),6,RoomNum),
    ZoneHouse = if_else(str_detect(都市計画,"住居"),1,0),
    ZoneBusiness = if_else(str_detect(都市計画,"商業"),1,0),
    ZoneFactory = if_else(str_detect(都市計画,"工業"),1,0),
    RoomL = if_else(str_detect(間取り,"Ｌ"),1,0),
    RoomD = if_else(str_detect(間取り,"Ｄ"),1,0),
    StructureSRC = if_else(建物の構造 == "ＳＲＣ",1,0),
    After = if_else(
      TradePeriod == 2021,
        1,
        0
    ),
    Reform = if_else(改装 == "改装済",1,0),
    District = 市区町村コード |> factor()
  ) |> 
  select(Quartely,Price:District) |> 
  na.omit()

Data <- recipe(
  Price ~.,
  Raw
  ) |> 
  step_filter(Tenure >= 0) |> 
  step_filter(Size >= 15) |> 
  step_filter(Size <= 110) |> 
  step_filter(Tenure <= 50) |> 
  step_filter(DistanceStation <= 20) |> 
  step_filter(Youseki <= 700) |> 
  step_filter(RoomNum <= 4) |> 
  step_embed(
    outcome = vars(Price),
    predictors = vars(District),
    num_terms = 5,
    hidden_units = 10,
    options = embed_control(epochs = 75, validation_split = 0.2)
  ) |> 
  prep()

Data$steps[[4]]

Group <- sample(
  1:2,
  nrow(Data),
  replace = TRUE
  )

X <- Data |> 
  select(
    -After,
    -Price
  )

BaseX <- Data |> 
  select(
    -After,
    -Price,
    -starts_with("District"),
    -DistanceStation
  )

Y <- Data$Price

D <- Data$After
```

# Learner

```{r SetLearner}
Mutate = po("mutate") # データ加工

Mutate$param_set$values$mutation = list(
  X1_2 = ~ X1*X1,
  X2_2 = ~ X2*X2,
  X3_2 = ~ X3*X3,
  X4_2 = ~ X4*X4,
  X5_2 = ~ X5*X5,
  X6_2 = ~ X6*X6,
  X7_2 = ~ X7*X7
) # 二乗項と交差項の作成

Scale = po("scale")

RegDuflo <-  Mutate %>>% 
  Scale %>>% 
  lrn(
  "regr.lm",
  id = "RegDuflo"
  ) |> 
  as_learner()

RegLM <- lrn(
  "regr.lm",
  id = "RegLM"
  )

RegRF <- lrn(
  "regr.ranger",
  id = "RefRF"
  )

RegStack <- pipeline_stacking(
  list(
    RegRF,
    RegLM
  ), 
  lrn(
    "regr.lm",
    id = "SuperLearner"
  ),
  use_features = FALSE,
  folds = 2) |> 
  as_learner()
```

# Train

```{r}
TaskY <- as_task_regr(
  X |> 
    mutate(Y = Y),
  target = "Y",
  id = "Y"
  )

TaskBaseY <- as_task_regr(
  BaseX |> 
    mutate(Y = Y),
  target = "Y",
  id = "Y Base"
  )

TaskD <- as_task_regr(
  X |> 
    mutate(D),
  target = "D",
  id = "D"
  )

TaskBaseD <- as_task_regr(
  BaseX |> 
    mutate(D),
  target = "D",
  id = "D Base"
  )

Group <- partition(
  TaskD,
  ratio = 0.5
)
```

# Nuiance

```{r}
HatY <- RegStack$
  clone()$
  train(TaskY, Group$train)$
  predict(TaskY, Group$test)

HatD <- RegStack$
  clone()$
  train(TaskD, Group$train)$
  predict(TaskD, Group$test)

HatBaseY <- RegStack$
  clone()$
  train(TaskBaseY, Group$train)$
  predict(TaskBaseY, Group$test)

HatBaseD <- RegStack$
  clone()$
  train(TaskBaseD, Group$train)$
  predict(TaskBaseD, Group$test)

A <- if_else(
  D[Group$test] == 1,
  1/(HatD$response),
  1/(1 - HatD$response)
  )

BaseA <- if_else(
  D[Group$test] == 1,
  1/(HatBaseD$response),
  1/(1 - HatBaseD$response)
  )

CD <- (1 - summary(lm(A ~ BaseA))$r.squared)/(summary(lm(A ~ BaseA))$r.squared)
CY <- summary(lm(Y[Group$test] - HatBaseY$response ~ HatY$response - HatBaseY$response))$r.squared

(CY*CD*(mean(Y[Group$test] - HatBaseY$response)^2)*(mean(BaseA)^2)) |> sqrt()

OhtY <- Y[Group$test] - HatY$response
OhtD <- D[Group$test] - HatD$response

lm(OhtY ~ 0 + OhtD)
```


# Comparision

```{r Estimation}
Design <- benchmark_grid(
  tasks = list(
    TaskY1,
    TaskBaseY1,
    TaskY0,
    TaskBaseY0,
    TaskD,
    TaskBaseD
  ),
  learners = list(
    RegStack$clone()
  ),
  resamplings = rsmp(
    "holdout",
    ratio = 1/2)
)

future::plan("multisession") # 並列処理

BenchMark <- benchmark(Design)

BenchMark$aggregate(msr("regr.rsq"))

```
