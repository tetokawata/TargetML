---
title: "Example"
format: html
execute: 
  warning: false
  message: false
---

# Test

- Simple split into 3

    - Cross validate

# SetUp

```{r SetUp}
set.seed(149)
pacman::p_load(
  tidyverse,
  mlr3verse,
  mlr3pipelines,
  mlr3extralearners,
  recipes
)

lgr::get_logger("mlr3")$set_threshold("error")
lgr::get_logger("bbotk")$set_threshold("error")
```


# Data

```{r CleanData}
TargetStructure <- c("ＳＲＣ","ＲＣ")

TargetRoom <- c("オープンフロア","スタジオ","メゾネット")

Raw <- arrow::read_parquet("~/Dropbox/DataClean/RetailJPN/AllPrefectture.parquet") |> 
  filter(今後の利用目的 == "住宅") |> 
  filter(用途 == "住宅") |> 
  filter(改装 != "") |> 
  filter(間取り != "") |> 
  filter(都市計画 != "") |> 
  filter(最寄駅.名称 != "") |> 
  filter(都道府県名 == "東京都") |> 
  filter(str_detect(市区町村名, "区")) |> 
  filter(建物の構造 %in% TargetStructure) |> 
  filter(!(間取り %in% TargetRoom)) |> 
  mutate(TradePeriod = str_sub(取引時点,1,4) |> 
           as.numeric()
         ) |> 
  filter(TradePeriod %in% c(2019,2021)) |> 
  mutate(
    TempBuildYear = 
      str_sub(建築年,3,-2) |> 
      as.numeric(),
    TempGengo = str_sub(建築年,1,2)
    ) |> 
  mutate(
    BuildYear = if_else(
      TempGengo == "令和",
      TempBuildYear + 2018,
      TempBuildYear
      )
  ) |> 
  mutate(
    BuildYear = if_else(
      TempGengo == "平成",
      TempBuildYear + 1988,
      BuildYear
      )
  ) |> 
  mutate(
    BuildYear = if_else(
      TempGengo == "昭和",
      TempBuildYear + 1925,
      BuildYear
      )
  ) |> 
  mutate(
    Price = 取引価格.総額./(10^6),
    Tenure = TradePeriod - BuildYear,
    DistanceStation = 最寄駅.距離.分. |> as.numeric(),
    Size = 面積... |> as.numeric(),
    Youseki = 容積率... |> as.numeric(),
    Kenpei = 建ぺい率... |> as.numeric(),
    RoomNum = if_else(str_detect(間取り,"１"),1,0),
    RoomNum = if_else(str_detect(間取り,"２"),2,RoomNum),
    RoomNum = if_else(str_detect(間取り,"３"),3,RoomNum),
    RoomNum = if_else(str_detect(間取り,"４"),4,RoomNum),
    RoomNum = if_else(str_detect(間取り,"５"),5,RoomNum),
    RoomNum = if_else(str_detect(間取り,"６"),6,RoomNum),
    ZoneHouse = if_else(str_detect(都市計画,"住居"),1,0),
    ZoneBusiness = if_else(str_detect(都市計画,"商業"),1,0),
    ZoneFactory = if_else(str_detect(都市計画,"工業"),1,0),
    RoomL = if_else(str_detect(間取り,"Ｌ"),1,0),
    RoomD = if_else(str_detect(間取り,"Ｄ"),1,0),
    StructureSRC = if_else(建物の構造 == "ＳＲＣ",1,0),
    After = if_else(
      TradePeriod == 2021,
        1,
        0
    ),
    Reform = if_else(改装 == "改装済",1,0),
    District = if_else(
      市区町村名 %in% c("千代田区","港区","中央区"),
      "CBD",
      市区町村名
      )
  ) |> 
  select(Price:District) |> 
  na.omit()

Data <- recipe(
  ~.,
  Raw
  ) |> 
  step_filter(Tenure >= 0) |> 
  step_filter(Size >= 15) |> 
  step_filter(Size <= 110) |> 
  step_filter(Tenure <= 50) |> 
  step_filter(DistanceStation <= 20) |> 
  step_filter(Youseki <= 700) |> 
  step_filter(RoomNum <= 4) |> 
  step_dummy(
    District,
    one_hot = TRUE) |> 
  step_scale(
    Tenure,
    DistanceStation,
    Size,
    Youseki,
    Kenpei,
    RoomNum
  ) |> 
  prep() |> 
  bake(new_data = NULL)

X <- Data |> 
  select(
    -Price,
    -After
  )

NameX <- names(X)
names(X) <- str_c("X",1:ncol(X))

Y <- Data$Price

D <- Data$After

Group <- sample(
  1:3,
  nrow(X),
  replace = TRUE
  )
```

# Learner

## Base

```{r}
Mutate = po("mutate") # データ加工

Mutate$param_set$values$mutation = list(
  X1_2 = ~ X1*X1,
  X2_2 = ~ X2*X2,
  X3_2 = ~ X3*X3,
  X4_2 = ~ X4*X4,
  X5_2 = ~ X5*X5,
  X6_2 = ~ X6*X6,
  X7_2 = ~ X7*X7
) # 二乗項と交差項の作成

Scale = po("scale")

RegLM <- Mutate %>>%
  Scale %>>% lrn(
  "regr.lm",
  id = "RegLM"
  ) |> 
  as_learner()

RegBART <- lrn(
  "regr.bart",
  id = "RefBART"
)

RegRF <- lrn(
  "regr.ranger",
  id = "RefRF"
  )
```


## Regression Learner

```{r SetNuisanceLearner}
RegStacking <- pipeline_stacking(
  list(
    RegRF,
    RegLM,
    RegBART
    ), 
  lrn(
    "regr.lm",
    id = "RegAggregate"
    ),
  folds = 2,
  use_features = FALSE) |> 
  as_learner()
```

## Signal Learner

```{r SetSignalLearner}
LearnSignal <- pipeline_stacking(
  list(
    RegRF,
    RegLM
    ), 
  lrn(
    "regr.lm",
    id = "RegAggregate"
    ),
  folds = 2,
  use_features = FALSE
  ) |> 
  as_learner()
```

# Learning

```{r Define Funciton}
MainEst <- function(
    TempNuisance,
    TempITE,
    TempConfirm){
  TempTask <- as_task_regr(
    X[Group == TempNuisance & D == 1, ] |>
      mutate(Y = Y[Group == TempNuisance & D == 1]),
    target = "Y",
    id = "Nuisance Y1"
    )
  FitY1 <- RegStacking$
    clone()$
    train(TempTask)
  
  TempTask <- as_task_regr(
    X[Group == TempNuisance & D == 0, ] |>
      mutate(Y = Y[Group == TempNuisance & D == 0]),
    target = "Y",
    id = "Nuisance Y0"
    )
  FitY0 <- RegStacking$
    clone()$
    train(TempTask)
  
  TempTask <- as_task_regr(
    X[Group == TempNuisance, ] |>
      mutate(Y = Y[Group == TempNuisance]),
    target = "Y",
    id = "Nuisance Y"
    )
  FitY <- RegStacking$
    clone()$
    train(TempTask)
  
  TempTask <- as_task_regr(
    X[Group == TempNuisance, ] |>
      mutate(D = D[Group == TempNuisance]),
    target = "D",
    id = "Nuisance D"
    )
  FitD <- RegStacking$
    clone()$
    train(TempTask)
  
  TempTask <- as_task_regr(
    X |>
      mutate(Y = Y),
    target = "Y",
    id = "Psude Problem"
    )
  PredY1 <- FitY1$predict(TempTask)
  PredY0 <- FitY0$predict(TempTask)
  PredY <- FitY$predict(TempTask)

  TempTask <- as_task_regr(
    X |>
      mutate(D = D),
    target = "D",
    id = "Psude Problem"
    )
  PredD <- FitD$predict(TempTask)
  ScoreY1 <- PredY1$response +
    (D / PredD$response) *
    (Y - PredY1$response)
  ScoreY0 <- PredY0$response +
    ((1 - D) / (1 - PredD$response)) *
    (Y - PredY0$response)
  ScoreAIPW <-
    ScoreY1 - ScoreY0
  TempTask <-
    as_task_regr(
      X[Group == TempITE, ] |>
        mutate(Y = ScoreAIPW[Group == TempITE]),
      target = "Y",
      id = "Lean ITE"
      )
  FitAIPW <- LearnSignal$
    clone()$
    train(TempTask)
  FitLinearAIPW <- lrn("regr.lm")$
    train(TempTask)
  OhtY <- Y - PredY$response
  OhtD <- D - PredD$response
  ScoreR <- OhtY / OhtD
  Weight <- OhtD^2
  TempTask <-
    as_task_regr(
      X[Group == TempITE, ] |>
        mutate(
          Y = ScoreR[Group == TempITE],
          Weight = Weight[Group == TempITE]
          ),
      target = "Y",
      id = "R"
      )
  TempTask$set_col_roles(
    "Weight",
    "weight"
    )
  FitR <- LearnSignal$
    clone()$
    train(TempTask)
  TempTask <-
    as_task_regr(
      X |>
        mutate(Y = ScoreAIPW),
      target = "Y"
      )
  PredAIPW <- FitAIPW$predict(TempTask)
  PredLinearAIPW <- FitLinearAIPW$predict(TempTask)
  PredR <- FitR$predict(TempTask)
  TempResult <- Data[Group == TempConfirm, ] |>
    mutate(
      PredAIPW = PredAIPW$response[Group == TempConfirm],
      PredLinearAIPW = PredLinearAIPW$response[Group == TempConfirm],
      PredR = PredR$response[Group == TempConfirm],
      ScoreAIPW = ScoreAIPW[Group == TempConfirm],
      ScoreR = ScoreR[Group == TempConfirm],
      ScoreY1 = ScoreY1[Group == TempConfirm],
      ScoreY0 = ScoreY0[Group == TempConfirm],
      PredD = PredD$response[Group == TempConfirm],
      PredY1 = PredY1$response[Group == TempConfirm],
      PredY0 = PredY0$response[Group == TempConfirm],
      PredY = PredY$response[Group == TempConfirm],
      )
  return(TempResult)
  }
```

# Confirm

## Estimation

```{r}
TempData <- MainEst(1,2,3) |> 
  bind_rows(MainEst(2,3,1)) |> 
  bind_rows(MainEst(3,1,2))
```

## Lower

```{r}
Q <- qnorm(1-(0.05/(2*9)))

Est <- function(q){
  Q_AIPW <- quantile(
    TempData$PredAIPW, 
    probs = q)
  Q_LinearAIPW <- quantile(
    TempData$PredLinearAIPW, 
    probs = q)
  Q_R <- quantile(
    TempData$PredR, 
    probs = q)
  
  TempAIPW <- Q_AIPW + 
    (1/q)*if_else(
      TempData$PredAIPW <= Q_AIPW,
      TempData$ScoreAIPW- Q_AIPW,
      0
      )
  TempLinearAIPW <- Q_LinearAIPW + 
    (1/q)*if_else(
      TempData$PredLinearAIPW <= Q_LinearAIPW,
      TempData$ScoreAIPW- Q_LinearAIPW,
      0
      )
  TempR <- Q_R + 
    (1/q)*if_else(
      TempData$PredR <= Q_R,
      TempData$ScoreAIPW- Q_R,
      0
      )
  TempResult <- estimatr::lm_robust(
    TempAIPW ~ 1
    ) |> 
    generics::tidy() |> 
    mutate(
      Quantile = q,
      Method = "AIPW with SL"
      ) |> 
    bind_rows(
      estimatr::lm_robust(
    TempLinearAIPW ~ 1
    ) |> 
    generics::tidy() |> 
    mutate(
      Quantile = q,
      Method = "AIPW with OLS"
      )
    ) |> 
    bind_rows(
      estimatr::lm_robust(
    TempR ~ 1
    ) |> 
    generics::tidy() |> 
    mutate(
      Quantile = q,
      Method = "R"
      )
    )
  return(TempResult)
}

map_dfr(seq(0.1,1,0.1),Est) |> 
  ggplot(
    aes(
      x = Quantile,
      y = estimate,
      ymin = estimate - Q*std.error,
      ymax = estimate + Q*std.error,
      color = Method,
      fill = Method
    )
  ) +
  theme_bw() +
  geom_line() +
  geom_ribbon(alpha = 0.3) +
  geom_ribbon(
    aes(
      ymin = estimate - 1.96*std.error,
      ymax = estimate + 1.96*std.error
    ),
    alpha = 0.5
  ) +
  facet_wrap(~Method)
```

## Upper

```{r}
Est <- function(q){
  Q_AIPW <- quantile(
    TempData$PredAIPW, 
    probs = q)
  Q_LinearAIPW <- quantile(
    TempData$PredLinearAIPW, 
    probs = q)
  Q_R <- quantile(
    TempData$PredR, 
    probs = q)
  
  TempAIPW <- Q_AIPW + 
    (1/(1-q))*if_else(
      TempData$PredAIPW >= Q_AIPW,
      TempData$ScoreAIPW- Q_AIPW,
      0
      )
  TempLinearAIPW <- Q_LinearAIPW + 
    (1/(1-q))*if_else(
      TempData$PredLinearAIPW >= Q_LinearAIPW,
      TempData$ScoreAIPW- Q_LinearAIPW,
      0
      )
  TempR <- Q_R + 
    (1/(1-q))*if_else(
      TempData$PredR >= Q_R,
      TempData$ScoreAIPW- Q_R,
      0
      )
  TempResult <- estimatr::lm_robust(
    TempAIPW ~ 1
    ) |> 
    generics::tidy() |> 
    mutate(
      Quantile = q,
      Method = "AIPW with SL"
      ) |> 
    bind_rows(
      estimatr::lm_robust(
    TempLinearAIPW ~ 1
    ) |> 
    generics::tidy() |> 
    mutate(
      Quantile = q,
      Method = "AIPW with OLS"
      )
    ) |> 
    bind_rows(
      estimatr::lm_robust(
    TempR ~ 1
    ) |> 
    generics::tidy() |> 
    mutate(
      Quantile = q,
      Method = "R"
      )
    )
  return(TempResult)
}

map_dfr(seq(0,0.9,0.1),Est) |> 
  ggplot(
    aes(
      x = Quantile,
      y = estimate,
      ymin = estimate - Q*std.error,
      ymax = estimate + Q*std.error,
      color = Method,
      fill = Method
    )
  ) +
  theme_bw() +
  geom_line() +
  geom_ribbon(alpha = 0.3) +
  geom_ribbon(
    aes(
      ymin = estimate - 1.96*std.error,
      ymax = estimate + 1.96*std.error
    ),
    alpha = 0.5
  ) +
  facet_wrap(~Method)
```
